#### 字符串匹配-KMP说明书

1. ##### 思想来源

   首先假设字符串主串为s<sub>1</sub>s<sub>2</sub>s<sub>3</sub>s<sub>4</sub>...s<sub>n</sub>,模式串为p<sub>1</sub>p<sub>2</sub>p<sub>3</sub>p<sub>4</sub>...p<sub>m</sub>.

   当做字符串匹配的暴力求解的时候,有可能是在第n次比较时主串的第i个字符和模式串的第j个字符不同.此时会将i和j回退到开头的后一位然后继续比较.

   但是其中可能出现情况是:在这第n次比较时,其实已经是知道主串i前面j个长度的字符串是什么样的,是没必要进行比较的.例如:已经比较过的主串i个字符是 *a b c a b*,模式串的j个字符是 *a b c a c*.这个时候用模式串的a和主串的b,c比较是没必要的,直接将模式串右滑,用模式串的第2位b去和主串的第5位b去比较就行了.因此,需要解决的问题就是当碰到不匹配的情况时,需要将模式串右滑多少.

2. ##### 右滑的操作

   所谓"右滑",即需要在模式串第j个字符和主串的第i个字符比较产生不匹配时.保持i不变,在模式串的j前面找到一个位序k,继续和i做比较.即目的就是找到这个位序k.

   假设现在找到了这个位序k.那么模式串在k前面的长度为k-1子串和主串在i前面长度为k-1的字串一定相同,即有等式:
   $$
   p_1p_2...p_{k-1}=s_{i-k+1}...s_{i-2}s_{i-1}
   $$
    而且不会有k`>k符合上面的等式.并且由之前模式串和主串已经做过的匹配,模式串j前面k-1长度的子串和主串i前面k-1长度的子串是一定相等的,就有下面的等式:
   $$
   p_{j-k+1}...p_{j-2}p_{j-1}=s_{i-k+1}...s_{i-2}s_{i-1}
   $$
   那么结合这两个等式,就能得出下面的等式:
   $$
   p_1p_2...p_{k-1}=p_{j-k+1}...p_{j-2}p_{j-1}
   $$
   可以看出,k的值完全和主串无关,只与模式串自身相关.

   因为当模式串在j的位置和主串在i的位置不匹配时,需要将模式串右滑到k,那么可以设定一个`next[j]=k`的函数,即当模式串在j的位序不匹配时,跳到k位序.结核上面的等式,可以得到一个next[j]的函数:
   $$
   next[j]=\begin{cases}
   0,当j=1的时候 \\
   Max\left\{k|1<k<j且p_1p_2...p_{k-1}=p_{j-k+1}...p_{j-2}p_{j-1} \right\},当此集合不为空的时候 \\
   1,当其他情况 \\
   \end{cases}
   $$


3. ##### next[j]数组的推导

   
