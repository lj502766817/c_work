#### 字符串匹配-KMP说明

1. ##### 思想来源

   首先假设字符串主串为s<sub>1</sub>s<sub>2</sub>s<sub>3</sub>s<sub>4</sub>...s<sub>n</sub>,模式串为p<sub>1</sub>p<sub>2</sub>p<sub>3</sub>p<sub>4</sub>...p<sub>m</sub>.

   当做字符串匹配的暴力求解的时候,有可能是在第n次比较时主串的第i个字符和模式串的第j个字符不同.此时会将i和j回退到开头的后一位然后继续比较.

   但是其中可能出现情况是:在这第n次比较时,其实已经是知道主串i前面j个长度的字符串是什么样的,是没必要进行比较的.例如:已经比较过的主串i个字符是 *a b c a b*,模式串的j个字符是 *a b c a c*.这个时候用模式串的a和主串的b,c比较是没必要的,直接将模式串右滑,用模式串的第2位b去和主串的第5位b去比较就行了.因此,需要解决的问题就是当碰到不匹配的情况时,需要将模式串右滑多少.

2. ##### 右滑的操作

   所谓"右滑",即需要在模式串第j个字符和主串的第i个字符比较产生不匹配时.保持i不变,在模式串的j前面找到一个位序k,继续和i做比较.即目的就是找到这个位序k.

   假设现在找到了这个位序k.那么模式串在k前面的长度为k-1子串和主串在i前面长度为k-1的字串一定相同,即有等式:
   
   $$
   p_1p_2...p_{k-1}=s_{i-k+1}...s_{i-2}s_{i-1}
   $$
   
    而且不会有k`>k符合上面的等式.并且由之前模式串和主串已经做过的匹配,模式串j前面k-1长度的子串和主串i前面k-1长度的子串是一定相等的,就有下面的等式:
    
   $$
   p_{j-k+1}...p_{j-2}p_{j-1}=s_{i-k+1}...s_{i-2}s_{i-1}
   $$
   
   那么结合这两个等式,就能得出下面的等式:
   
   $$
   p_1p_2...p_{k-1}=p_{j-k+1}...p_{j-2}p_{j-1}
   $$
   
   可以看出,k的值完全和主串无关,只与模式串自身相关.

   因为当模式串在j的位置和主串在i的位置不匹配时,需要将模式串右滑到k,那么可以设定一个`next[j]=k`的函数,即当模式串在j的位序不匹配时,跳到k位序.结核上面的等式,可以得到一个next[j]的函数:
   
   $$
   next[j]=\begin{cases}
   0,当j=1的时候 \\
   Max\begin{Bmatrix}k|1<k<j且p_1p_2...p_{k-1}=p_{j-k+1}...p_{j-2}p_{j-1} \end{Bmatrix},当此集合不为空的时候 \\
   1,当其他情况 \\
   \end{cases}
   $$

   那么在有next[j]函数的情况下,字符串的匹配操作可以变为:

   > 当$s_i \neq p_j$时,找到k=next[j],然后将$s_i$和$p_k$进行对比,如果不行就再找k = next[k]继续比较.依次类推,直到next[1]=0的情况下,就直接++i,++j.

3. ##### next[j]数组的推导

   首先由定义知`next[1]=0`.那么可以假设`next[j]=k`,此时模式串中有:
   
   $$
   p_1p_2...p_{k-1}=p_{j-k+1}...p_{j-2}p_{j-1}
   $$
   
   那么想要知道`next[j+1]`的值,需要考虑两种情况 $p_k=p_j$ 和 $p_k \neq p_j$ :

   + $p_k=p_j$ 的情况:

     此时模式串中有:
     $$
     p_1p_2...p_{k-1}p_k=p_{j-k+1}...p_{j-2}p_{j-1}p_j
     $$
     则next[j+1]=k+1=next[j]+1.

   + $p_k \neq p_j$ 的情况:

     此时模式串的情况是$p_1p_2...p_{k-1}p_k \neq p_{j-k+1}...p_{j-2}p_{j-1}p_j$,那么就需要重新找到一个k\`<k使得模式串中有:
     
     $$
     p_1p_2...p_{k\`}=p_{j-k\`+1}...p_{j-1}p_{j}
     $$
     
     则next[j+1]=k\`+1.

     现在就需要求得k\`的值.可以看到求k\`的值相当于是用模式串本身作为一个主串P和模式串p进行比较.那么根据之前的情况下已经知道$P_{j-k+1}...P_{j-2}P_{j-1}=p_{1}...p_{k-2}p_{k-1}$,因此需要将模式串p左滑将$P_j$和$p_{next[j]}$做比较,直到找到一个next[j]使得等式成立,则此时的next[j]=k\`.也有可能右滑到最后这个k\`也没有找到,那么此时next[j+1]=1.

4. ##### next[j]数组的优化

   上面推导出的next[j]数组还有缺陷,例如:当模式串是a a a a b时,对应的`next[j]={0,1,2,3,4}`,然而模式串的第1,2,3个字符和第4个字符是相等,那么如果next[5]都不能和主串匹配上的话,那么next[4],next[3],next[2]肯定不能和主串匹配.因此需要优化next[j]数组的推导过程.

   即当$s_i \neq p_j$时,如果$p_j=p_{next[j]}$的话直接跳过next[j]查看next[next[j]],依次类推来推导next[j]函数的修正值数组nextVal[j].
